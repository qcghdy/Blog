堆
数据结构 = 结构定义 + 结构操作



二叉树
怎么看二叉树？
结构定义：1-2树，最关键的信息，其实是方向性。
结构操作：遍历
根据遍历的方向，是深度，还是广度，其实遍历的难点，就是要关联这种方向性，来进一步遍历。
对于深度遍历来说，深度遍历，前中后序
对于广度遍历来说，也就是层序遍历，一层层遍历。那么每一层从左往右遍历，就像每一层都是一个链表一样。这里的方向性有两个，一个从左往右（关联左右节点），一个从上到下（跨层）。由此引出 层序遍历，有两一种比较关键的方法：引入额外的空间来存储每一层的值，即使用栈。

栈相当于解决了横向关联的问题。那么在有一类型的问题，是给每个指针增加一个next指针，做横向关联的情况下，就可以引入第二种优化方式：
（2）不引入额外的空间，由于树的最左子树其实已经把上下层级单向串联起来（本身就是个链表），那么只要引入一个dummy哑节点来保存下一层的头，cur表示当前层的遍历节点，就可以完美解决上下层级遍历和横向遍历两个问题


二分查搜索树

结构定义：1-2树，但树的节点有大小关系。如果按照二叉树的中序遍历，出来的结果就是一个从小到大排序的序列。
结构操作： 查找
二分法查找key。典型的用法：查找排名为K的节点，查找公共祖先。


结构操作：构建
由于二分搜索树的值有顺序特点，所以按照前中后序出来的结果也都用一定特点：前序序列中第一个是根节点，后序序列中最后一个是根节点，中序遍历中从小到大排序了。由此，
可以通过前序&中序，或者后续&中序，来反推构造出BST

结构操作：插入和删除
关键思路：由于二分查找树的中序遍历是有序的，因此插入节点和删除节点，都是可对应到在中序数组中的
二分查找发找到对应位置，如果对应的位置为空，即要插入的最小子树中的根只有一边子节点，则直接写进入，比如 [1，null，4]，（leetcode对二叉树的表达形式）插入2，则直接插入到null的位置即可;
如果两边走占满了，[1,2,4],（leetcode对二叉树的表达形式）要插入3，则会插入成[1,2,4,null,null,3,null]
删除

二叉查找树，是一个有序的结构，这种结构可以动态高效的维护树的更新（插入、查询、删除）
由二分查找算法，引出二叉查找树，主要就是二分查找算法对应的数组，在插入和删除操作升成本很大，但数组对于更新操作来说却很非常方便


快速排序
结构定义：数组，链表
结构操作：
排序的本质，就是让合适的数据找到合适的位置。如果我们假定有一个值，它已经在正确的位置上了，他把整个区间分成3个部分，左区间，它自己，右区间，就变得和二叉树类似，左子树，根节点，右子树。对于这个区间来讲，左边都是小于他的（但此时左边区域内的点可能还是乱序的），右边的都是大于他的（此时右边区域的点也可能还是乱序）。这个准确的位置，我们叫他轴点，pivot。
找到轴点后，依此再对左右子区间递归快排算法即可，那么当这个区间只有一个节点时，递归条件终止。

所以快速排序的平均复杂度是O(NlogN).每一次找到轴点需要遍历N个元素，但树的高度其实是logN，最坏的情况就是只有一边子树，O(N2).
预计此，

快照找到第K个元素，以及前K个元素。这类问题的核心，就不一定要求前K个完全有序，只要找到前K个即可。

难点是怎么选取轴点？基本算法值选取头或者尾，优化算法是三点定位法，选取首尾中三个位置的三个值，取值中间的为轴点。

N个数据中的查找 TOP K问题
结构定义：N小， K小，用快速查找发； N大 K 大，归并排序； N大，K小，堆排

堆
结构定义：
就是一种完全二叉树，一颗满二叉树去掉叶子节点中的一些最右侧的节点。他的实际存储结构是数组，这个数组的下标是一段从下标1开始的连续存储空间

他是一种 维护集合中最值的 高效的数据结构
结构操作：
插入，删除最值， 从尾部插入节点，从头部删除最值，因此，堆是一种优先队列




